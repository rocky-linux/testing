#!/bin/bash

# Script takes 2 arguments: SOURCEREPO and TARGETREPO  (ex:  ./repo_compare_html.sh  RHEL8_BaseOS   Rocky8_BaseOS )
# The arguments must be named dnf/yum repos on the system
#
# We will loop through the RPM names from SOURCEREPO, and attempt to find name/version/release matches in TARGETREPO
# An HTML table page will be output showing the differences
#
# -Skip Grube, 2021-06-29

REPO1="$1"
REPO2="$2"

pkglist1=`dnf repoquery --latest-limit 1 --repo ${REPO1}   --queryformat "%{name} %{version} %{release}"  |  grep -vi " subscription "` #| tr '\n' ','`
pkglist2=`dnf repoquery --latest-limit 1 --repo ${REPO2}   --queryformat "%{name} %{version} %{release}"  |  grep -vi " subscription "` 

# Strip ending moduleXYZ and .el8* information away from the release info, as 
# They may not match (or will never match in the module's case)
pkglist1=`echo "${pkglist1}" | sed -e 's/\.module.*$/\.module/g'   |  sed -e 's/\.el.*$//g'`
pkglist2=`echo "${pkglist2}" | sed -e 's/\.module.*$/\.module/g'   |  sed -e 's/\.el.*$//g'`


# Turn the first pkg list into a comma-separated list (instead of newline-separated)
# (makes it easier to use IFS=',' in all of our for loops)
pkglist1=`echo "${pkglist1}" | tr '\n' ','`


#echo "$pkglist1" > debug1.txt
#echo "$pkglist2" > debug2.txt


# HTML style header for table:
echo "<html><h3>Repo Version Differences for:  ${REPO1}   vs.   ${REPO2}</h3>"
echo '
<style>
table {
  border-collapse: collapse;
  width: 60%;
}

th, td {
  text-align: left;
  padding: 8px;
}

tr:nth-child(even) {background-color: #d4d4d4;}
</style>

<div style="overflow-x:auto;">
'

echo "
<i>Generated by Repo Compare Script at:  `date +'%Y-%m-%d  %H:%M:%S'` </i>
<br />

<table>
<tr><th>${REPO1} Version</th>   <th>${REPO2} Version</th></tr>

"



IFS=','
# Main loop to check all packages from our "source" repo
for pkg in `echo "${pkglist1}"`; do

  # Extract name/version/tag info from package (filtering out modular + el8* info from tag)
  _name=`echo "$pkg" | awk '{print $1}'`
  _version=`echo "$pkg" | awk '{print $2}'`
  _tag=`echo "$pkg" | awk '{print $3}'`   # | sed -e 's/\.module.*$/\.module/g'   |  sed -e 's/\.el.*$//g'`
  
  # every package match is false by default, until we match it
  isPkgMatched=0
  
  
  # Find any packages in the target repo with the same name as the one we're interested in from the source repo:
  # (easy to match the exact name if we include a space separator in our grep)
  # (We turn it into a comma separated list as well so we can do another for loop against the result set)
  pkgmatches=`echo "${pkglist2}"  |  grep "^${_name} "`
  
  
  # If there are no matches, we output a DOES NOT EXIST and don't bother with searching the results
  if [[ -z "${pkgmatches}" ]]; then
    echo "<tr> <td>${_name}-${_version}-${_tag}</td>  <td>(DOES NOT EXIST)</td>  </tr>"
    continue
  fi
  

  # Loop through each result (name matches) and look for an exact version match:
  for match in `echo "${pkgmatches}"`; do
    _name2=`echo "$match" | awk '{print $1}'`  
    _version2=`echo "$match" | awk '{print $2}'`
    _tag2=`echo "$match" | awk '{print $3}'` # |  tr -d ',' |  sed -e 's/\.module.*$/\.module/g'   |  sed -e 's/\.el.*$//g'`
    #echo "DEBUG :: _tag2 == $_tag2"
    
    # If we find a match, then exit this loop and set the flag to found:
    if [ "${_name}-${_version}-${_tag}" == "${_name2}-${_version2}-${_tag2}" ]; then 
      isPkgMatched=1
      break
    fi  
  done

  # Get pkgmatches into name-version-release format:
  pkgmatches=`echo "${pkgmatches}" | sed 's/ /\-/g'  |  sed 's/,$//'`
  
  # If package is not matched, then we need to output an HTML row:
  if [ "$isPkgMatched" == "0" ]; then
    echo "<tr> <td>${_name}-${_version}-${_tag}</td>  <td>${pkgmatches}</td>  </tr>"
  fi
  
done


echo "</table></html>"

