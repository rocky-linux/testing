#!/bin/bash

# Script takes 2 arguments: SOURCEREPO and TARGETREPO  (ex:  ./repo_compare_html.sh  RHEL8_BaseOS   Rocky8_BaseOS )
# The arguments must be named dnf/yum repos on the system
#
# We will loop through the RPM names from SOURCEREPO, and attempt to find name/version/release matches in TARGETREPO
# An HTML table page will be output showing the differences
#
# -Skip Grube, 2021-06-29


REPO1="$1"
REPO2="$2"

pkglist1=$(dnf repoquery --latest-limit 1 --repo "${REPO1}"   --queryformat "%{name} %{version} %{release}"  |  grep -vi " subscription ")
pkglist2=$(dnf repoquery --latest-limit 1 --repo "${REPO2}"   --queryformat "%{name} %{version} %{release}"  |  grep -vi " subscription ")

# Strip ending moduleXYZ and .el8* information away from the release info, as 
# They may not match (or will never match in the module's case)
pkglist1=$(echo "${pkglist1}" | sed -e 's/\.module.*$/\.module/g'   |  sed -e 's/\.el.*$//g')
pkglist2=$(echo "${pkglist2}" | sed -e 's/\.module.*$/\.module/g'   |  sed -e 's/\.el.*$//g')


# Turn the first pkg list into a comma-separated list (instead of newline-separated)
# (makes it easier to use IFS=',' in all of our for loops)
pkglist1=$(echo "${pkglist1}" | tr '\n' ',')


#echo "$pkglist1" > debug1.txt
#echo "$pkglist2" > debug2.txt



# HTML style header for table:
echo "<html><h3>Repo Version Differences for:  ${REPO1}   vs.   ${REPO2}</h3>"
echo '
<style>
table {
  border-collapse: collapse;
  width: 90%;
}

th, td {
  text-align: left;
  padding: 8px;
}

tr:nth-child(even) {background-color: #d4d4d4;}
</style>

<div style="overflow-x:auto;">
'

echo "
<i>Generated by Repo Compare Script at:  $(date +'%Y-%m-%d  %H:%M:%S') </i>
<br />

<table>
<tr><th>${REPO1} Version</th>   <th>${REPO2} Version</th></tr>

"



IFS=','
# Main loop to check all packages from our "source" repo
for pkg in ${pkglist1}; do

  # Extract name/version/tag info from package (filtering out modular + el8* info from tag)
  _name=$(echo "$pkg" | awk '{print $1}')
  _version=$(echo "$pkg" | awk '{print $2}')
  _tag=$(echo "$pkg" | awk '{print $3}')
  
  # every package match is false by default, until we match it
  isPkgMatched=0
  
  
  # Find any packages in the target repo with the same name as the one we're interested in from the source repo:
  # (easy to match the exact name if we include a space separator in our grep)
  # (We turn it into a comma separated list as well so we can do another for loop against the result set)
  pkgmatches=$(echo "${pkglist2}"  |  grep "^${_name} ")
  
  
  # If there are no matches, we output a DOES NOT EXIST and don't bother with searching the results
  if [[ -z "${pkgmatches}" ]]; then
    echo "<tr> <td>${_name}-${_version}-${_tag}</td>  <td>(DOES NOT EXIST)</td>  </tr>"
    continue
  fi
  

  # Loop through each result (name matches) and look for an exact version match:
  for match in ${pkgmatches}; do
    _name2=$(echo "$match" | awk '{print $1}') 
    _version2=$(echo "$match" | awk '{print $2}')
    _tag2=$(echo "$match" | awk '{print $3}')
    #echo "DEBUG :: _tag2 == $_tag2"
    
    # If we find a match, then exit this loop and set the flag to found:
    if [ "${_name}-${_version}-${_tag}" == "${_name2}-${_version2}-${_tag2}" ]; then 
      isPkgMatched=1
      break
    fi  
  done

  # Get pkgmatches into name-version-release format:
  pkgmatches=$(echo "${pkgmatches}" | sed 's/ /\-/g'  |  sed 's/,$//')
  
  # If package is not matched, then we need to output an HTML row:
  if [ "$isPkgMatched" == "0" ]; then
    echo "<tr> <td>${_name}-${_version}-${_tag}</td>  <td>${pkgmatches}</td>  </tr>"
  fi
  
done


echo "</table></html>"

